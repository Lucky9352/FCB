{% extends 'base.html' %}
{% load static %}

{% block title %}{{ game.name }} - Game Details{% endblock %}

{% block extra_head %}
<!-- Force browser to reload JavaScript - no caching -->
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
{% endblock %}

{% block extra_css %}
<style>
    .slot-card {
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        border: 2px solid transparent;
    }
    .slot-card:hover {
        transform: translateY(-4px);
        border-color: rgba(233, 69, 96, 0.5);
        box-shadow: 0 20px 40px rgba(0,0,0,0.3);
    }
    .capacity-indicator {
        display: inline-flex;
        align-items: center;
        gap: 4px;
    }
    .capacity-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        transition: all 0.3s ease;
    }
    .capacity-dot.booked {
        background-color: #ef4444;
        box-shadow: 0 0 8px rgba(239, 68, 68, 0.6);
    }
    .capacity-dot.reserved {
        background-color: #f59e0b;
        box-shadow: 0 0 8px rgba(245, 158, 11, 0.6);
        animation: pulse-reserved 2s ease-in-out infinite;
    }
    .capacity-dot.available {
        background-color: #10b981;
        box-shadow: 0 0 8px rgba(16, 185, 129, 0.6);
    }
    
    @keyframes pulse-reserved {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.6; }
    }
    .date-tab {
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    .date-tab.active {
        background: linear-gradient(135deg, #e94560 0%, #00d4aa 100%);
        transform: scale(1.05);
    }
    .date-tab:hover:not(.active) {
        transform: translateY(-3px);
        box-shadow: 0 8px 20px rgba(0,0,0,0.4);
    }
    .scrollbar-hide {
        -ms-overflow-style: none;
        scrollbar-width: none;
    }
    .scrollbar-hide::-webkit-scrollbar {
        display: none;
    }
    
    /* Skeleton loading animation */
    .skeleton {
        animation: skeleton-loading 1s linear infinite alternate;
        background: linear-gradient(90deg, #2d2d2d 25%, #3d3d3d 50%, #2d2d2d 75%);
        background-size: 200% 100%;
    }
    @keyframes skeleton-loading {
        0% { background-position: 200% 0; }
        100% { background-position: -200% 0; }
    }
    
    .fade-in {
        animation: fadeIn 0.4s ease-out;
    }
    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(20px); }
        to { opacity: 1; transform: translateY(0); }
    }
    
    /* Loading spinner */
    .loading-spinner {
        display: inline-block;
        width: 50px;
        height: 50px;
        border: 5px solid rgba(255, 255, 255, 0.1);
        border-top-color: #e94560;
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
    }
    @keyframes spin {
        to { transform: rotate(360deg); }
    }
    
    .loading-overlay {
        position: relative;
        min-height: 400px;
    }
    
    .loading-message {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        z-index: 10;
    }
    
    /* Pulse animation for loading text */
    .pulse {
        animation: pulse 1.5s ease-in-out infinite;
    }
    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
    }
    
    /* Spot selector button styles */
    .spot-selector-btn {
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .spot-selector-btn:hover {
        transform: scale(1.05);
    }
    
    .spot-selector-btn.scale-110 {
        transform: scale(1.1);
    }
    
    /* Modal animation */
    #spotSelectionModal {
        animation: modalFadeIn 0.3s ease-out;
        backdrop-filter: blur(10px);
    }
    
    @keyframes modalFadeIn {
        from {
            opacity: 0;
            transform: scale(0.95);
        }
        to {
            opacity: 1;
            transform: scale(1);
        }
    }
    
    /* Disabled button style */
    .btn-disabled {
        background: rgba(107, 114, 128, 0.3) !important;
        color: rgba(156, 163, 175, 0.8) !important;
        cursor: not-allowed !important;
        opacity: 0.6;
    }
    
    .btn-disabled:hover {
        transform: none !important;
        box-shadow: none !important;
    }
</style>
{% endblock %}

{% block content %}
<div class="min-h-screen py-8" style="background: linear-gradient(to bottom right, #111827, #1a202e, #1f2937);">
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        
        <!-- Back Button -->
        <div class="mb-6">
            <a href="{% url 'home' %}" class="inline-flex items-center text-white hover:text-gaming-highlight transition-colors">
                <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path>
                </svg>
                Back to Home
            </a>
        </div>

        <!-- Game Header -->
        <div class="card border-2 border-white/10 mb-8 overflow-hidden">
            <div class="grid grid-cols-1 lg:grid-cols-5 gap-0">
                <!-- Game Image -->
                <div class="lg:col-span-2 h-96 lg:h-auto relative overflow-hidden">
                    {% if game.image %}
                    <img src="{{ game.image.url }}" alt="{{ game.name }}" class="w-full h-full object-cover">
                    {% else %}
                        <!-- Enhanced Placeholder based on game type -->
                        {% if 'pool' in game.name|lower or '8' in game.name or 'ball' in game.name|lower %}
                        <div class="w-full h-full bg-gradient-to-br from-emerald-900 via-teal-800 to-cyan-900 flex items-center justify-center relative overflow-hidden">
                            <!-- Pool table felt texture effect -->
                            <div class="absolute inset-0 opacity-20" style="background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.3) 2px, rgba(0,0,0,0.3) 4px);"></div>
                            <!-- Pool balls decoration -->
                            <div class="relative z-10 flex flex-col items-center">
                                <div class="flex gap-6 mb-6">
                                    <div class="w-24 h-24 rounded-full bg-white shadow-2xl flex items-center justify-center">
                                        <span class="text-4xl font-black text-gray-800">8</span>
                                    </div>
                                    <div class="w-24 h-24 rounded-full bg-gradient-to-br from-red-500 to-red-700 shadow-2xl"></div>
                                </div>
                                <div class="flex gap-6">
                                    <div class="w-24 h-24 rounded-full bg-gradient-to-br from-yellow-400 to-yellow-600 shadow-2xl"></div>
                                    <div class="w-24 h-24 rounded-full bg-gradient-to-br from-blue-500 to-blue-700 shadow-2xl"></div>
                                </div>
                            </div>
                            <!-- Cue stick decoration -->
                            <div class="absolute bottom-16 right-16 w-64 h-3 bg-gradient-to-r from-amber-800 to-amber-600 transform rotate-45 opacity-50 rounded-full shadow-xl"></div>
                        </div>
                        {% elif 'tennis' in game.name|lower or 'table tennis' in game.name|lower or 'ping' in game.name|lower %}
                        <div class="w-full h-full bg-gradient-to-br from-blue-900 via-indigo-800 to-purple-900 flex items-center justify-center relative overflow-hidden">
                            <!-- Table tennis table effect -->
                            <div class="absolute inset-0 flex items-center justify-center">
                                <div class="w-4/5 h-3/5 bg-blue-600 opacity-20 rounded-lg border-4 border-white/30"></div>
                                <div class="absolute w-4/5 h-2 bg-white/40 top-1/2 transform -translate-y-1/2"></div>
                            </div>
                            <!-- Ping pong elements -->
                            <div class="relative z-10 flex flex-col items-center gap-8">
                                <!-- Paddles -->
                                <div class="flex gap-12 items-center">
                                    <div class="relative">
                                        <div class="w-28 h-32 rounded-full bg-gradient-to-br from-red-600 to-red-800 shadow-2xl"></div>
                                        <div class="w-8 h-20 bg-amber-700 absolute bottom-0 left-1/2 transform -translate-x-1/2 translate-y-16 rounded shadow-xl"></div>
                                    </div>
                                    <div class="w-16 h-16 rounded-full bg-white shadow-2xl animate-pulse"></div>
                                    <div class="relative">
                                        <div class="w-28 h-32 rounded-full bg-gradient-to-br from-gray-800 to-gray-900 shadow-2xl"></div>
                                        <div class="w-8 h-20 bg-amber-700 absolute bottom-0 left-1/2 transform -translate-x-1/2 translate-y-16 rounded shadow-xl"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        {% else %}
                        <div class="w-full h-full bg-gradient-to-br from-primary-600 via-purple-600 to-secondary-600 flex items-center justify-center relative overflow-hidden">
                            <div class="absolute inset-0 opacity-10" style="background: radial-gradient(circle at 30% 50%, rgba(255,255,255,0.2) 0%, transparent 50%);"></div>
                            <div class="relative z-10">
                                <i class="bi bi-trophy-fill text-white text-9xl opacity-80 drop-shadow-2xl"></i>
                            </div>
                        </div>
                        {% endif %}
                    {% endif %}
                    
                    <!-- Booking Type Badge -->
                    <div class="absolute top-4 right-4">
                        {% if game.booking_type == 'HYBRID' %}
                        <span class="badge badge-success text-sm shadow-lg">
                            ü§ù Private + Shared Available
                        </span>
                        {% else %}
                        <span class="badge badge-primary text-sm shadow-lg">
                            üîí Private Booking Only
                        </span>
                        {% endif %}
                    </div>
                </div>

                <!-- Game Info -->
                <div class="lg:col-span-3 p-8 lg:p-10">
                    <h1 class="text-5xl font-black text-white mb-4">{{ game.name }}</h1>
                    <p class="text-gray-300 text-lg mb-8 leading-relaxed">{{ game.description|default:"Professional gaming experience with premium equipment and perfect ambiance." }}</p>
                    
                    <!-- Game Details Grid -->
                    <div class="grid grid-cols-2 gap-4 mb-8">
                        <div class="bg-white/5 rounded-xl p-5 border border-white/10 hover:bg-white/10 transition-all">
                            <div class="text-gray-400 text-sm mb-2 flex items-center gap-2">
                                <i class="bi bi-people-fill text-primary-400"></i>
                                Capacity
                            </div>
                            <div class="text-white text-2xl font-bold">{{ game.capacity }} Player{{ game.capacity|pluralize }}</div>
                        </div>
                        
                        <div class="bg-white/5 rounded-xl p-5 border border-white/10 hover:bg-white/10 transition-all">
                            <div class="text-gray-400 text-sm mb-2 flex items-center gap-2">
                                <i class="bi bi-clock-fill text-secondary-400"></i>
                                Slot Duration
                            </div>
                            <div class="text-white text-2xl font-bold">{{ game.slot_duration_minutes }} Minutes</div>
                        </div>
                        
                        <div class="bg-gradient-to-br from-red-500/20 to-pink-500/20 rounded-xl p-5 border border-red-400/30 hover:border-red-400/50 transition-all">
                            <div class="text-red-200 text-sm mb-2 flex items-center gap-2">
                                <i class="bi bi-wallet2"></i>
                                Private Price
                            </div>
                            <div class="text-white text-2xl font-bold">‚Çπ{{ game.private_price }}</div>
                        </div>
                        
                        {% if game.booking_type == 'HYBRID' %}
                        <div class="bg-gradient-to-br from-green-500/20 to-emerald-500/20 rounded-xl p-5 border border-green-400/30 hover:border-green-400/50 transition-all">
                            <div class="text-green-200 text-sm mb-2 flex items-center gap-2">
                                <i class="bi bi-wallet2"></i>
                                Shared Price (per person)
                            </div>
                            <div class="text-white text-2xl font-bold">‚Çπ{{ game.shared_price }}</div>
                        </div>
                        {% endif %}
                    </div>

                    {% if not is_authenticated %}
                    <!-- Login CTA for non-authenticated users -->
                    <div class="bg-gradient-to-r from-primary-600 to-secondary-600 rounded-xl p-6 text-center">
                        <p class="text-white font-bold text-lg mb-4">Login to book this game!</p>
                        <a href="{% url 'authentication:customer_login' %}?next={{ request.path }}" 
                           class="btn btn-light btn-lg hover-glow">
                            <i class="bi bi-box-arrow-in-right"></i>
                            Login Now
                        </a>
                    </div>
                    {% endif %}
                </div>
            </div>
        </div>

        <!-- Date Selection -->
        <div class="mb-10">
            <h2 class="text-3xl font-black text-white mb-6 flex items-center gap-3">
                <i class="bi bi-calendar-event text-primary-400"></i>
                Select Date
            </h2>
            <div class="flex space-x-4 overflow-x-auto pb-4 scrollbar-hide py-2">
                {% for date in date_range %}
                <button type="button"
                        onclick="selectDate('{{ date.isoformat }}')" 
                        class="date-tab flex-shrink-0 px-8 py-4 rounded-xl text-center min-w-[140px] transition-all duration-300 {% if date == selected_date %}active text-white shadow-2xl{% else %}bg-white/5 text-gray-300 hover:bg-white/10{% endif %} border-2 border-white/10"
                        data-date="{{ date.isoformat }}">
                    <div class="font-bold text-lg mb-1">
                        {% if date == today %}Today{% else %}{{ date|date:"M d" }}{% endif %}
                    </div>
                    <div class="text-sm opacity-80">{{ date|date:"D" }}</div>
                </button>
                {% endfor %}
            </div>
        </div>

        <!-- Available Slots for Selected Date -->
        <div>
            <h2 class="text-3xl font-black text-white mb-6 flex items-center gap-3">
                <i class="bi bi-clock-history text-secondary-400"></i>
                <span>Available Time Slots</span>
                <span id="liveIndicator" class="ml-auto flex items-center gap-2 text-xs font-medium text-success opacity-0 transition-opacity duration-300">
                    <span class="w-2 h-2 rounded-full bg-success animate-pulse"></span>
                    Live Updates Active
                </span>
            </h2>
            <div class="mb-4 card p-4 flex items-center justify-between">
                <span class="text-gray-300 font-medium" id="selectedDateDisplay">{{ selected_date|date:"l, F d, Y" }}</span>
                {% if selected_date == today %}
                <span class="badge badge-primary">Today</span>
                {% endif %}
            </div>
            
            <!-- Slots Container - Loaded via AJAX -->
            <div id="slotsContainer">
                <!-- Initial Loading State -->
                <div class="loading-overlay">
                    <div class="loading-message fade-in">
                        <div class="loading-spinner mx-auto mb-4"></div>
                        <p class="text-white text-lg font-medium pulse">Loading available slots...</p>
                        <p class="text-gray-400 text-sm mt-2">Fetching the latest availability</p>
                    </div>
                </div>
            </div>
        </div>

    </div>
</div>

<!-- Unified Booking Modal -->
<div id="unifiedBookingModal" class="fixed inset-0 bg-black bg-opacity-75 z-50 hidden flex items-center justify-center p-4" onclick="closeUnifiedModal(event)">
    <div class="bg-gradient-to-br from-gaming-secondary to-gaming-accent rounded-2xl max-w-md w-full p-8 border border-white/20" onclick="event.stopPropagation()">
        <div class="text-center mb-6">
            <div class="text-6xl mb-4">üéÆ</div>
            <h3 class="text-2xl font-bold text-white mb-2">Book Your Spot</h3>
            <p class="text-gray-300 text-sm">Select individual spots or book the full table</p>
        </div>

        <!-- Full Table Toggle -->
        <div id="fullTableToggle" class="mb-6 p-4 bg-gradient-to-r from-blue-500/20 to-purple-500/20 rounded-xl border-2 border-blue-400/30 cursor-pointer hover:border-blue-400/50 transition-all" onclick="toggleFullTable()">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <i class="bi bi-lock-fill text-blue-300 text-2xl"></i>
                    <div>
                        <div class="text-white font-bold">Book Full Table</div>
                        <div class="text-blue-200 text-xs">Exclusive access for your group</div>
                    </div>
                </div>
                <div class="flex items-center gap-2">
                    <span id="fullTablePrice" class="text-blue-300 font-bold text-lg">‚Çπ0</span>
                    <div id="fullTableCheckbox" class="w-6 h-6 rounded border-2 border-blue-300 flex items-center justify-center transition-all">
                        <i class="bi bi-check text-white text-xl hidden"></i>
                    </div>
                </div>
            </div>
        </div>

        <!-- Individual Spot Selection -->
        <div id="spotSelectionSection">
            <div class="text-white font-medium mb-3 flex items-center gap-2">
                <i class="bi bi-people-fill text-purple-300"></i>
                <span>Or select individual spots</span>
            </div>
            <div id="spotSelectionGrid" class="grid grid-cols-4 gap-3 mb-6">
                <!-- Dynamically filled -->
            </div>
        </div>

        <!-- Total Price Display -->
        <div class="bg-white/10 rounded-lg p-4 mb-6 border border-white/20">
            <div class="flex justify-between items-center">
                <span class="text-gray-300">Total Price:</span>
                <span id="totalPriceDisplay" class="text-gaming-highlight text-2xl font-bold">‚Çπ0</span>
            </div>
            <div class="text-xs text-gray-400 mt-1">
                <span id="bookingTypeDisplay">Select spots to continue</span>
            </div>
        </div>

        <!-- Action Buttons -->
        <div class="flex space-x-3">
            <button onclick="closeUnifiedModal()" 
                    class="flex-1 bg-white/10 hover:bg-white/20 text-white px-6 py-3 rounded-lg font-medium transition-colors border border-white/20">
                Cancel
            </button>
            <button id="confirmBookingButton" onclick="confirmUnifiedBooking()" 
                    class="flex-1 bg-gaming-highlight hover:bg-gaming-highlight/80 text-white px-6 py-3 rounded-lg font-semibold transition-colors shadow-lg disabled:opacity-50 disabled:cursor-not-allowed"
                    disabled>
                Confirm Booking
            </button>
        </div>
    </div>
</div>

<script>
// Version: 2.2 - FIXED: Capacity dots now properly show booked/reserved/available states
// Last updated: 2025-11-06 21:45 UTC
// CACHE BUSTER: v2.2.001
// Configuration
const isAuthenticated = '{{ is_authenticated|yesno:"true,false" }}';
const gameId = "{{ game.id }}";
const csrfToken = "{{ csrf_token }}";
let currentDate = "{{ selected_date.isoformat }}";

// Format date display
function formatDateDisplay(dateStr) {
    const date = new Date(dateStr + 'T00:00:00');
    const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
    return date.toLocaleDateString('en-US', options);
}

// Check if date is today
function isToday(dateStr) {
    const today = new Date();
    const date = new Date(dateStr + 'T00:00:00');
    return date.toDateString() === today.toDateString();
}

// Select date and load slots
function selectDate(dateStr) {
    currentDate = dateStr;
    
    // Update active state on date buttons with smooth transition
    document.querySelectorAll('.date-tab').forEach(btn => {
        if (btn.dataset.date === dateStr) {
            btn.classList.add('active', 'text-white', 'shadow-2xl');
            btn.classList.remove('bg-white/5', 'text-gray-300');
        } else {
            btn.classList.remove('active', 'text-white', 'shadow-2xl');
            btn.classList.add('bg-white/5', 'text-gray-300');
        }
    });
    
    // Update date display
    const displayText = formatDateDisplay(dateStr);
    const displayElement = document.getElementById('selectedDateDisplay');
    if (displayElement) {
        displayElement.textContent = displayText;
    }
    
    // Scroll slots container into view smoothly
    document.getElementById('slotsContainer').scrollIntoView({ 
        behavior: 'smooth', 
        block: 'nearest' 
    });
    
    // Stop current polling
    stopPolling();
    
    // Load slots for selected date
    loadSlotsForDate(dateStr);
    
    // Restart polling immediately
    setTimeout(() => {
        startPolling();
    }, 1000);
}

// Load slots via API (OPTIMIZED WITH AJAX)
function loadSlotsForDate(dateStr) {
    const container = document.getElementById('slotsContainer');
    
    // Show beautiful loading spinner with message
    container.innerHTML = `
        <div class="loading-overlay">
            <div class="loading-message fade-in">
                <div class="loading-spinner mx-auto mb-4"></div>
                <p class="text-white text-lg font-medium pulse">Loading slots...</p>
                <p class="text-gray-400 text-sm mt-2">Please wait a moment</p>
            </div>
        </div>
    `;
    
    // Fetch slots from API
    fetch(`/api/games/${gameId}/slots/?date=${dateStr}`)
        .then(response => {
            if (!response.ok) {
                throw new Error('Failed to load slots');
            }
            return response.json();
        })
        .then(data => {
            currentSlotsData = data.slots; // Store for comparison
            renderSlots(data.slots);
        })
        .catch(error => {
            showError('Unable to load slots. Please try again.');
        });
}

// Render slots from API data
function renderSlots(slots) {
    const container = document.getElementById('slotsContainer');
    
    if (!slots || slots.length === 0) {
        container.innerHTML = `
            <div class="text-center py-20 card fade-in">
                <div class="text-gray-400 text-7xl mb-6">üìÖ</div>
                <p class="text-white text-2xl font-bold mb-3">No slots available for this date</p>
                <p class="text-gray-400 text-lg">Try selecting a different date or check back later</p>
            </div>
        `;
        return;
    }
    
    let html = '<div class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-6">';
    
    slots.forEach(slot => {
        const availability = slot.availability;
        const bookingOptions = slot.booking_options;
        
        html += `
            <div class="slot-card card hover-lift fade-in">
                <!-- Time Header -->
                <div class="flex items-center justify-between mb-4 pb-4 border-b border-white/10">
                    <div class="flex items-center gap-3">
                        <i class="bi bi-clock text-primary-400 text-2xl"></i>
                        <span class="text-white font-black text-2xl">
                            ${slot.time_display}
                        </span>
                    </div>
                    <div class="capacity-indicator">
                        ${renderCapacityDots(availability)}
                        <span class="text-sm text-gray-400 ml-2 font-medium">
                            ${availability.truly_available_spots !== undefined ? availability.truly_available_spots : availability.available_spots}/${availability.total_capacity}
                        </span>
                    </div>
                </div>

                <!-- Reservation Info (if any) -->
                ${availability.reserved_spots > 0 ? `
                <div class="mb-3 p-3 bg-yellow-500/10 border border-yellow-500/30 rounded-lg">
                    <div class="flex items-center gap-2 text-yellow-300 text-xs">
                        <i class="bi bi-clock-history"></i>
                        <span class="font-medium">${availability.reserved_spots} spot${availability.reserved_spots !== 1 ? 's' : ''} reserved (payment pending)</span>
                    </div>
                </div>
                ` : ''}

                <!-- Booking Options -->
                <div class="space-y-3">
                    ${renderBookingOptions(slot, bookingOptions)}
                </div>

                ${availability.truly_available_spots === 0 && availability.reserved_spots === 0 ? `
                <div class="mt-4 text-center">
                    <span class="inline-flex items-center gap-2 bg-error/20 text-error px-4 py-2 rounded-lg text-sm font-bold border border-error/30">
                        <i class="bi bi-x-circle-fill"></i>
                        Fully Booked
                    </span>
                </div>
                ` : ''}
                
                ${availability.truly_available_spots === 0 && availability.reserved_spots > 0 ? `
                <div class="mt-4 text-center">
                    <span class="inline-flex items-center gap-2 bg-yellow-500/20 text-yellow-300 px-4 py-2 rounded-lg text-sm font-bold border border-yellow-500/30">
                        <i class="bi bi-hourglass-split"></i>
                        All Spots Reserved (Check back in a few minutes)
                    </span>
                </div>
                ` : ''}
            </div>
        `;
    });
    
    html += '</div>';
    container.innerHTML = html;
}

// Render capacity indicator dots with real-time updates (booked, reserved, available)
function renderCapacityDots(availability) {
    let html = '';
    const bookedSpots = availability.booked_spots || 0;
    const reservedSpots = availability.reserved_spots || 0;
    const totalCapacity = availability.total_capacity || 0;
    
    console.log('üî¥ renderCapacityDots called:', {
        booked: bookedSpots,
        reserved: reservedSpots,
        total: totalCapacity,
        truly_available: availability.truly_available_spots,
        available_spots: availability.available_spots
    });
    
    for (let i = 0; i < totalCapacity; i++) {
        let dotClass = 'available';
        
        if (i < bookedSpots) {
            dotClass = 'booked'; // Red - confirmed bookings
        } else if (i < bookedSpots + reservedSpots) {
            dotClass = 'reserved'; // Yellow/Orange - pending payment
        }
        
        html += `<div class="capacity-dot ${dotClass}" data-spot-index="${i}" title="${dotClass}"></div>`;
    }
    return html;
}

// Update capacity dots with animation when availability changes
function updateCapacityDotsWithAnimation(slotElement, newAvailability) {
    const dots = slotElement.querySelectorAll('.capacity-dot');
    const bookedSpots = newAvailability.booked_spots || 0;
    const reservedSpots = newAvailability.reserved_spots || 0;
    
    dots.forEach((dot, index) => {
        // Determine what state this dot should be in
        let targetClass = 'available';
        if (index < bookedSpots) {
            targetClass = 'booked'; // Red - confirmed bookings
        } else if (index < bookedSpots + reservedSpots) {
            targetClass = 'reserved'; // Yellow/Orange - pending payment
        }
        
        // Get current state
        const currentClass = dot.classList.contains('booked') ? 'booked' : 
                           dot.classList.contains('reserved') ? 'reserved' : 'available';
        
        // Only update if state changed
        if (currentClass !== targetClass) {
            // Remove all state classes
            dot.classList.remove('booked', 'reserved', 'available');
            // Add new state class
            dot.classList.add(targetClass);
            // Update title attribute
            dot.setAttribute('title', targetClass);
            // Animate the change
            dot.style.transform = 'scale(1.3)';
            setTimeout(() => {
                dot.style.transform = 'scale(1)';
            }, 300);
        }
    });
    
    // Update availability text
    const availabilityText = slotElement.querySelector('.capacity-indicator span');
    if (availabilityText) {
        const oldText = availabilityText.textContent;
        const trulyAvailable = newAvailability.truly_available_spots !== undefined ? newAvailability.truly_available_spots : newAvailability.available_spots;
        const newText = `${trulyAvailable}/${newAvailability.total_capacity}`;
        if (oldText !== newText) {
            availabilityText.textContent = newText;
            availabilityText.style.color = '#10b981';
            setTimeout(() => {
                availabilityText.style.color = '';
            }, 1000);
        }
    }
}

// Render booking options (unified booking card)
function renderBookingOptions(slot, options) {
    if (!options || options.length === 0) {
        return '<p class="text-gray-400 text-sm">No booking options available</p>';
    }
    
    // Extract pricing info from options
    let privatePrice = 0;
    let sharedPrice = 0;
    let capacity = 0;
    let availableSpots = 0;
    let maxSpotsPerBooking = 4;
    let canBookPrivate = false;
    let canBookShared = false;
    
    options.forEach(option => {
        if (option.type === 'PRIVATE') {
            privatePrice = option.price;
            capacity = option.capacity;
            canBookPrivate = option.available;
        } else if (option.type === 'SHARED') {
            sharedPrice = option.price_per_spot || option.price || 0;
            availableSpots = option.available_spots || 0;
            maxSpotsPerBooking = option.max_spots_per_booking || 4;
            canBookShared = option.available;
        }
    });
    
    // Determine if any booking is available
    const anyAvailable = canBookPrivate || canBookShared;
    const disabled = !anyAvailable;
    
    return renderUnifiedBookingOption(slot, {
        privatePrice,
        sharedPrice,
        capacity,
        availableSpots,
        maxSpotsPerBooking,
        canBookPrivate,
        canBookShared,
        disabled
    });
}

// Render unified booking option  
function renderUnifiedBookingOption(slot, bookingInfo) {
    const { privatePrice, sharedPrice, capacity, availableSpots, maxSpotsPerBooking, canBookPrivate, canBookShared, disabled } = bookingInfo;
    
    // CRITICAL: Always use slot.availability data, never fall back to options
    const availability = slot.availability || {};
    
    // Use truly_available_spots if available, otherwise calculate it
    let trulyAvailable;
    if (availability.truly_available_spots !== undefined) {
        trulyAvailable = availability.truly_available_spots;
    } else if (availability.available_spots !== undefined && availability.reserved_spots !== undefined) {
        trulyAvailable = Math.max(0, availability.available_spots - availability.reserved_spots);
    } else {
        trulyAvailable = availability.available_spots || availableSpots || 0;
    }
    
    const reservedSpots = availability.reserved_spots || 0;
    const totalCapacity = availability.total_capacity || capacity || 0;
    
    // Debug logging - KEEP THIS TO VERIFY DATA
    console.log('üéÆ Slot Booking Card:', {
        slot_id: slot.id,
        time: slot.time_display,
        available_spots: availability.available_spots,
        truly_available_spots: availability.truly_available_spots,
        reserved_spots: reservedSpots,
        booked_spots: availability.booked_spots,
        total_capacity: availability.total_capacity,
        calculated_truly_available: trulyAvailable
    });
    
    return `
        <div class="bg-gradient-to-br from-purple-500/20 to-pink-600/20 border-2 border-purple-400/30 rounded-xl p-4 hover:border-purple-400/50 transition-all">
            <div class="flex items-center justify-between mb-3">
                <span class="text-purple-200 font-bold flex items-center gap-2">
                    <i class="bi bi-calendar-check"></i>
                    Book This Slot
                </span>
                <span class="text-purple-300 font-black text-xl">‚Çπ${sharedPrice}/spot</span>
            </div>
            <div class="text-purple-200 text-sm mb-3 opacity-90">
                <span class="text-green-300 font-bold">${trulyAvailable} available</span>
                ${reservedSpots > 0 ? ` ‚Ä¢ <span class="text-yellow-300">${reservedSpots} reserved</span>` : ''}
                ‚Ä¢ ${totalCapacity} total
            </div>
            ${isAuthenticated === 'true' ? `
                <button onclick="showUnifiedBookingModal('${slot.id}', ${trulyAvailable}, ${sharedPrice}, ${privatePrice}, ${totalCapacity}, ${Math.min(trulyAvailable, maxSpotsPerBooking)}, ${canBookPrivate}, ${canBookShared})" 
                        ${disabled || trulyAvailable === 0 ? 'disabled' : ''}
                        class="w-full ${disabled || trulyAvailable === 0 ? 'btn-disabled' : 'btn btn-primary hover-glow'} transition-all">
                    ${disabled || trulyAvailable === 0 ? '<i class="bi bi-x-circle"></i> Not Available' : '<i class="bi bi-calendar-check"></i> Select Spots'}
                </button>
            ` : `
                <a href="/accounts/login/?next=${encodeURIComponent(window.location.pathname)}" 
                   class="btn btn-primary w-full text-center hover-glow">
                    <i class="bi bi-box-arrow-in-right"></i> Login to Book
                </a>
            `}
        </div>
    `;
}

// Show error message
function showError(message) {
    const container = document.getElementById('slotsContainer');
    container.innerHTML = `
        <div class="text-center py-16 bg-red-500/10 rounded-2xl border border-red-500/30 fade-in">
            <div class="text-red-400 text-6xl mb-4">‚ö†Ô∏è</div>
            <p class="text-red-300 text-lg mb-2">${message}</p>
            <button onclick="loadSlotsForDate(currentDate)" 
                    class="mt-4 bg-red-500 hover:bg-red-600 text-white px-6 py-2 rounded-lg transition-colors">
                Try Again
            </button>
        </div>
    `;
}

{% if is_authenticated %}
// Unified booking modal variables
let selectedSlotId = null;
let selectedSpots = 0;
let pricePerSpot = 0;
let privatePrice = 0;
let maxSpots = 0;
let totalCapacity = 0;
let isFullTable = false;
let canBookPrivate = true;
let canBookShared = true;

// Show unified booking modal
function showUnifiedBookingModal(slotId, availableSpots, spotPrice, fullTablePrice, capacity, maxSpotsPerBooking, allowPrivate, allowShared) {
    selectedSlotId = slotId;
    pricePerSpot = spotPrice;
    privatePrice = fullTablePrice;
    maxSpots = Math.min(availableSpots, maxSpotsPerBooking);
    totalCapacity = capacity;
    selectedSpots = 0;
    isFullTable = false;
    canBookPrivate = allowPrivate;
    canBookShared = allowShared;
    
    // Track modal state for real-time updates
    isModalOpen = true;
    currentModalSlotId = slotId;
    
    // Update full table price display
    document.getElementById('fullTablePrice').textContent = `‚Çπ${fullTablePrice}`;
    
    // Show/hide full table option based on availability
    const fullTableToggle = document.getElementById('fullTableToggle');
    if (canBookPrivate) {
        fullTableToggle.style.display = 'block';
        fullTableToggle.style.opacity = '1';
    } else {
        fullTableToggle.style.display = 'none';
    }
    
    // Show/hide spot selection based on availability
    const spotSelectionSection = document.getElementById('spotSelectionSection');
    if (canBookShared) {
        spotSelectionSection.style.display = 'block';
    } else {
        spotSelectionSection.style.display = 'none';
    }
    
    // Build spot selection grid
    const grid = document.getElementById('spotSelectionGrid');
    grid.innerHTML = '';
    
    for (let i = 1; i <= maxSpots; i++) {
        const button = document.createElement('button');
        button.className = 'spot-selector-btn bg-white/10 hover:bg-white/20 text-white rounded-lg py-4 font-bold text-lg transition-all border-2 border-white/20 hover:border-gaming-highlight';
        button.textContent = i;
        button.onclick = () => selectNumberOfSpots(i);
        grid.appendChild(button);
    }
    
    // Reset full table checkbox
    resetFullTableCheckbox();
    
    // Update displays
    updateUnifiedPriceDisplay();
    
    // Show modal
    document.getElementById('unifiedBookingModal').classList.remove('hidden');
    document.getElementById('unifiedBookingModal').classList.add('flex');
}

// Toggle full table booking
function toggleFullTable() {
    if (!canBookPrivate) {
        alert('Full table booking is not available for this slot');
        return;
    }
    
    isFullTable = !isFullTable;
    
    const checkbox = document.getElementById('fullTableCheckbox');
    const checkIcon = checkbox.querySelector('i');
    const spotButtons = document.querySelectorAll('.spot-selector-btn');
    
    if (isFullTable) {
        // Enable full table mode
        checkbox.classList.add('bg-blue-500', 'border-blue-500');
        checkIcon.classList.remove('hidden');
        
        // Disable individual spot selection
        spotButtons.forEach(btn => {
            btn.disabled = true;
            btn.classList.add('opacity-50', 'cursor-not-allowed');
            btn.classList.remove('bg-gaming-highlight', 'border-gaming-highlight', 'scale-110', 'shadow-lg');
        });
        
        selectedSpots = totalCapacity;
    } else {
        // Disable full table mode
        checkbox.classList.remove('bg-blue-500', 'border-blue-500');
        checkIcon.classList.add('hidden');
        
        // Enable individual spot selection
        spotButtons.forEach(btn => {
            btn.disabled = false;
            btn.classList.remove('opacity-50', 'cursor-not-allowed');
        });
        
        selectedSpots = 0;
    }
    
    updateUnifiedPriceDisplay();
}

// Reset full table checkbox
function resetFullTableCheckbox() {
    isFullTable = false;
    const checkbox = document.getElementById('fullTableCheckbox');
    const checkIcon = checkbox.querySelector('i');
    checkbox.classList.remove('bg-blue-500', 'border-blue-500');
    checkIcon.classList.add('hidden');
}

// Select number of spots
function selectNumberOfSpots(spots) {
    if (isFullTable) {
        // Disable full table mode when selecting individual spots
        isFullTable = false;
        resetFullTableCheckbox();
    }
    
    selectedSpots = spots;
    
    // AUTO-DETECT FULL TABLE: If user selects all available spots, treat as full table
    if (spots === totalCapacity && canBookPrivate) {
        isFullTable = true;
        const checkbox = document.getElementById('fullTableCheckbox');
        const checkIcon = checkbox.querySelector('i');
        checkbox.classList.add('bg-blue-500', 'border-blue-500');
        checkIcon.classList.remove('hidden');
    }
    
    // Update button states
    const buttons = document.querySelectorAll('.spot-selector-btn');
    buttons.forEach((btn, index) => {
        if (index + 1 === spots) {
            btn.classList.add('bg-gaming-highlight', 'border-gaming-highlight', 'scale-110', 'shadow-lg');
            btn.classList.remove('bg-white/10', 'border-white/20');
        } else {
            btn.classList.remove('bg-gaming-highlight', 'border-gaming-highlight', 'scale-110', 'shadow-lg');
            btn.classList.add('bg-white/10', 'border-white/20');
        }
    });
    
    // Update price display
    updateUnifiedPriceDisplay();
}

// Update price display for unified modal
function updateUnifiedPriceDisplay() {
    const confirmButton = document.getElementById('confirmBookingButton');
    const bookingTypeDisplay = document.getElementById('bookingTypeDisplay');
    
    if (isFullTable) {
        // Full table booking - use private price
        document.getElementById('totalPriceDisplay').textContent = `‚Çπ${privatePrice}`;
        
        // Check if auto-converted (selected all spots individually)
        if (selectedSpots === totalCapacity) {
            bookingTypeDisplay.innerHTML = `Full table (${totalCapacity} spots) ‚Ä¢ <span class="text-green-300">‚úì Private price applied</span>`;
        } else {
            bookingTypeDisplay.textContent = `Full table (${totalCapacity} spots) ‚Ä¢ Private booking price`;
        }
        confirmButton.disabled = false;
    } else if (selectedSpots > 0) {
        // Individual spots booking - use shared price
        const totalPrice = selectedSpots * pricePerSpot;
        document.getElementById('totalPriceDisplay').textContent = `‚Çπ${totalPrice}`;
        bookingTypeDisplay.textContent = `${selectedSpots} spot${selectedSpots !== 1 ? 's' : ''} √ó ‚Çπ${pricePerSpot} per spot`;
        confirmButton.disabled = false;
    } else {
        // No selection
        document.getElementById('totalPriceDisplay').textContent = `‚Çπ0`;
        bookingTypeDisplay.textContent = 'Select spots to continue';
        confirmButton.disabled = true;
    }
}

// Close unified booking modal
function closeUnifiedModal(event) {
    if (event && event.target !== event.currentTarget) return;
    
    const modal = document.getElementById('unifiedBookingModal');
    modal.classList.add('hidden');
    modal.classList.remove('flex');
    
    // Reset modal tracking
    isModalOpen = false;
    currentModalSlotId = null;
    
    // Reset all variables
    selectedSlotId = null;
    selectedSpots = 0;
    pricePerSpot = 0;
    privatePrice = 0;
    maxSpots = 0;
    totalCapacity = 0;
    isFullTable = false;
}

// Confirm unified booking
function confirmUnifiedBooking() {
    // Comprehensive validation
    if (!selectedSlotId) {
        alert('Slot information missing. Please close and try again.');
        return;
    }
    
    if (selectedSpots === 0 || selectedSpots < 1) {
        alert('Please select at least 1 spot or enable full table booking');
        return;
    }
    
    // Determine booking type
    const bookingType = isFullTable ? 'PRIVATE' : 'SHARED';
    
    // Store values before closing modal (to prevent reset)
    const slotIdToBook = selectedSlotId;
    const spotsToBook = selectedSpots;
    
    // Close modal (this will reset the global variables)
    closeUnifiedModal();
    
    // Proceed with booking using stored values
    bookSlot(slotIdToBook, bookingType, spotsToBook, null);
}

// Book a slot
function bookSlot(slotId, bookingType, spotsRequested, event) {
    // Comprehensive validation before making request
    if (!slotId) {
        showBookingError('Slot information missing. Please try again.');
        return;
    }
    
    if (!bookingType || !['PRIVATE', 'SHARED'].includes(bookingType)) {
        showBookingError('Invalid booking type. Please try again.');
        return;
    }
    
    if (!spotsRequested || spotsRequested < 1) {
        showBookingError('Invalid number of spots. Please try again.');
        return;
    }
    
    const bookingData = {
        game_slot_id: slotId,
        booking_type: bookingType,
        spots_requested: spotsRequested
    };
    
    // Show loading state on button if event is provided
    let clickedButton = null;
    if (event && event.target) {
        clickedButton = event.target;
        clickedButton.disabled = true;
        const originalText = clickedButton.innerHTML;
        clickedButton.innerHTML = '<i class="bi bi-arrow-repeat animate-spin"></i> Processing...';
        clickedButton.dataset.originalText = originalText;
    }
    
    // Disable confirm button in modal to prevent double-clicks
    const confirmButton = document.getElementById('confirmBookingButton');
    if (confirmButton) {
        confirmButton.disabled = true;
        confirmButton.innerHTML = '<i class="bi bi-arrow-repeat animate-spin"></i> Processing...';
    }
    
    // Create booking using AJAX
    fetch('/booking/games/book/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrfToken
        },
        body: JSON.stringify(bookingData)
    })
    .then(response => {
        if (!response.ok) {
            return response.json().then(err => {
                throw err;
            });
        }
        return response.json();
    })
    .then(data => {
        if (data.success) {
            // Redirect to confirmation page
            window.location.href = data.redirect_url;
        } else {
            // Restore button states
            if (clickedButton && clickedButton.dataset.originalText) {
                clickedButton.disabled = false;
                clickedButton.innerHTML = clickedButton.dataset.originalText;
            }
            if (confirmButton) {
                confirmButton.disabled = false;
                confirmButton.innerHTML = 'Confirm Booking';
            }
            
            // Handle specific error types
            handleBookingError(data);
        }
    })
    .catch(error => {
        // Restore button states
        if (clickedButton && clickedButton.dataset.originalText) {
            clickedButton.disabled = false;
            clickedButton.innerHTML = clickedButton.dataset.originalText;
        }
        if (confirmButton) {
            confirmButton.disabled = false;
            confirmButton.innerHTML = 'Confirm Booking';
        }
        
        // Handle error
        handleBookingError(error);
    });
}

// Handle booking errors with better UX
function handleBookingError(error) {
    const errorType = error.error_type || 'unknown';
    const errorMessage = error.error || error.message || 'Booking failed';
    const errorDetails = error.details || '';
    
    // Check if it's an availability error (race condition)
    if (errorMessage.includes('not available') || 
        errorMessage.includes('no longer available') || 
        errorMessage.includes('Only') || 
        errorMessage.includes('spots available')) {
        
        // Close modal
        closeUnifiedModal();
        
        // Show availability error with refresh option
        showAvailabilityError(errorMessage, errorDetails);
        
        // Force refresh slots immediately
        loadSlotsForDate(currentDate);
        
    } else if (error.redirect_url && errorMessage === 'Authentication required') {
        // Redirect to login
        window.location.href = error.redirect_url;
    } else {
        // Generic error
        showBookingError(errorMessage + (errorDetails ? '\n\n' + errorDetails : ''));
    }
}

// Show availability error with refresh option
function showAvailabilityError(message, details) {
    const notification = document.createElement('div');
    notification.className = 'fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-[60] max-w-md w-full mx-4';
    notification.innerHTML = `
        <div class="bg-gradient-to-br from-red-900/95 to-red-800/95 backdrop-blur-xl rounded-2xl p-6 border-2 border-red-500/50 shadow-2xl animate-shake">
            <div class="flex items-start gap-4">
                <div class="flex-shrink-0">
                    <div class="w-12 h-12 bg-red-500/20 rounded-full flex items-center justify-center">
                        <i class="bi bi-exclamation-triangle-fill text-red-300 text-2xl"></i>
                    </div>
                </div>
                <div class="flex-1">
                    <h3 class="text-white font-bold text-lg mb-2">Availability Changed</h3>
                    <p class="text-red-100 text-sm mb-1">${message}</p>
                    ${details ? `<p class="text-red-200 text-xs mt-2">${details}</p>` : ''}
                    <p class="text-red-200 text-xs mt-3 italic">The page has been refreshed with current availability.</p>
                </div>
            </div>
            <div class="mt-4 flex gap-3">
                <button onclick="this.closest('.fixed').remove()" 
                        class="flex-1 bg-white/10 hover:bg-white/20 text-white px-4 py-2 rounded-lg font-medium transition-colors border border-white/20">
                    Close
                </button>
                <button onclick="this.closest('.fixed').remove(); loadSlotsForDate(currentDate);" 
                        class="flex-1 bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-lg font-semibold transition-colors shadow-lg">
                    <i class="bi bi-arrow-clockwise"></i> Refresh Again
                </button>
            </div>
        </div>
    `;
    
    document.body.appendChild(notification);
    
    // Auto-remove after 8 seconds
    setTimeout(() => {
        if (notification.parentElement) {
            notification.style.opacity = '0';
            notification.style.transform = 'translate(-50%, -50%) scale(0.95)';
            setTimeout(() => notification.remove(), 300);
        }
    }, 8000);
}

// Show generic booking error
function showBookingError(message) {
    alert(message);
}

// Add animations for notifications
const style = document.createElement('style');
style.textContent = `
    @keyframes shake {
        0%, 100% { transform: translate(-50%, -50%) translateX(0); }
        10%, 30%, 50%, 70%, 90% { transform: translate(-50%, -50%) translateX(-10px); }
        20%, 40%, 60%, 80% { transform: translate(-50%, -50%) translateX(10px); }
    }
    .animate-shake {
        animation: shake 0.5s ease-in-out;
    }
    @keyframes slideIn {
        from {
            opacity: 0;
            transform: translateX(100%);
        }
        to {
            opacity: 1;
            transform: translateX(0);
        }
    }
    .animate-slide-in {
        animation: slideIn 0.3s ease-out;
    }
`;
document.head.appendChild(style);
{% endif %}

// Smart polling system - adapts based on activity
let pollingInterval = null;
let currentPollingInterval = 5000; // Start with 5 seconds
const MIN_POLLING_INTERVAL = 3000; // Minimum 3 seconds when active
const MAX_POLLING_INTERVAL = 15000; // Maximum 15 seconds when idle
const ACTIVE_POLLING_INTERVAL = 3000; // Fast polling when changes detected
let consecutiveNoChanges = 0;
let isModalOpen = false;
let currentModalSlotId = null;
let lastFetchTime = 0;
let isFetching = false;

function startPolling() {
    // Clear any existing interval
    if (pollingInterval) {
        clearInterval(pollingInterval);
    }
    
    // Show live indicator
    const liveIndicator = document.getElementById('liveIndicator');
    if (liveIndicator) {
        liveIndicator.style.opacity = '1';
    }
    
    // Reset to active polling
    currentPollingInterval = ACTIVE_POLLING_INTERVAL;
    consecutiveNoChanges = 0;
    
    // Start smart polling
    pollSlots();
    pollingInterval = setInterval(pollSlots, currentPollingInterval);
}

function pollSlots() {
    // Prevent overlapping requests
    if (isFetching) {
        return;
    }
    
    // Don't poll if page is hidden
    if (document.hidden) {
        return;
    }
    
    isFetching = true;
    lastFetchTime = Date.now();
    
    fetch(`/api/games/${gameId}/slots/?date=${currentDate}`)
        .then(response => {
            if (response.ok) {
                return response.json();
            }
            throw new Error('API request failed');
        })
        .then(data => {
            if (data && data.slots) {
                // Check if modal is open and availability changed for that slot
                if (isModalOpen && currentModalSlotId) {
                    checkModalSlotAvailability(data.slots);
                }
                
                // Update slots display if data has changed
                const hasChanges = updateSlotsIfChanged(data.slots);
                
                // Adjust polling interval based on activity
                adjustPollingInterval(hasChanges);
            }
        })
        .catch(error => {
            console.error('Polling error:', error);
        })
        .finally(() => {
            isFetching = false;
        });
}

function adjustPollingInterval(hasChanges) {
    if (hasChanges) {
        // Changes detected - use fast polling
        consecutiveNoChanges = 0;
        if (currentPollingInterval !== ACTIVE_POLLING_INTERVAL) {
            currentPollingInterval = ACTIVE_POLLING_INTERVAL;
            restartPollingWithNewInterval();
        }
    } else {
        // No changes - gradually slow down polling
        consecutiveNoChanges++;
        
        if (consecutiveNoChanges >= 3) {
            // After 3 polls with no changes, slow down
            const newInterval = Math.min(currentPollingInterval * 1.5, MAX_POLLING_INTERVAL);
            if (newInterval !== currentPollingInterval) {
                currentPollingInterval = newInterval;
                restartPollingWithNewInterval();
            }
        }
    }
}

function restartPollingWithNewInterval() {
    if (pollingInterval) {
        clearInterval(pollingInterval);
    }
    pollingInterval = setInterval(pollSlots, currentPollingInterval);
}

// Check if the slot in the open modal has changed availability
function checkModalSlotAvailability(slots) {
    // CRITICAL: Only check if modal is actually open
    if (!isModalOpen || !currentModalSlotId) {
        return;
    }
    
    const currentSlot = slots.find(slot => slot.id === currentModalSlotId);
    
    if (!currentSlot) {
        // Slot might be filtered out (past slot) or truly unavailable
        // Silently return - this is normal when slots become past slots
        return;
    }
    
    // Check if availability has changed significantly
    const availability = currentSlot.availability;
    const bookingOptions = currentSlot.booking_options;
    
    if (!availability || !bookingOptions) {
        // Missing data, silently return
        return;
    }
    
    // Store previous state to detect actual changes
    if (!window.previousModalAvailability) {
        const sharedOpt = bookingOptions.find(opt => opt.type === 'SHARED');
        const privateOpt = bookingOptions.find(opt => opt.type === 'PRIVATE');
        
        window.previousModalAvailability = {
            available_spots: availability.available_spots || 0,
            canBookShared: sharedOpt ? sharedOpt.available : false,
            canBookPrivate: privateOpt ? privateOpt.available : false
        };
        return; // First check, just store state
    }
    
    const prev = window.previousModalAvailability;
    
    // Find shared option
    const sharedOption = bookingOptions.find(opt => opt.type === 'SHARED');
    const privateOption = bookingOptions.find(opt => opt.type === 'PRIVATE');
    
    // If the slot became fully booked (and wasn't before)
    if (availability.available_spots === 0 && prev.available_spots > 0) {
        closeUnifiedModal();
        showAvailabilityError('This time slot just became fully booked.', 'Please select a different time slot.');
        window.previousModalAvailability = null;
        return;
    }
    
    // If shared booking is no longer available but was before
    if (sharedOption && !sharedOption.available && prev.canBookShared) {
        closeUnifiedModal();
        showAvailabilityError('Shared booking is no longer available for this slot.', 'Someone just booked it privately.');
        window.previousModalAvailability = null;
        return;
    }
    
    // If private booking is no longer available but was before
    if (privateOption && !privateOption.available && prev.canBookPrivate) {
        closeUnifiedModal();
        showAvailabilityError('Private booking is no longer available for this slot.', 'Someone just made a shared booking.');
        window.previousModalAvailability = null;
        return;
    }
    
    // If available spots decreased below selected spots
    if (selectedSpots > 0 && !isFullTable && availability.available_spots < selectedSpots && availability.available_spots < prev.available_spots) {
        // Update the modal with new availability
        const newMaxSpots = Math.min(availability.available_spots, 4);
        maxSpots = newMaxSpots;
        
        // Reset selection
        selectedSpots = 0;
        isFullTable = false;
        
        // Rebuild spot grid
        const grid = document.getElementById('spotSelectionGrid');
        if (grid) {
            grid.innerHTML = '';
            for (let i = 1; i <= newMaxSpots; i++) {
                const button = document.createElement('button');
                button.className = 'spot-selector-btn bg-white/10 hover:bg-white/20 text-white rounded-lg py-4 font-bold text-lg transition-all border-2 border-white/20 hover:border-gaming-highlight';
                button.textContent = i;
                button.onclick = () => selectNumberOfSpots(i);
                grid.appendChild(button);
            }
        }
        
        // Show warning notification
        showAvailabilityWarning(`Only ${availability.available_spots} spot${availability.available_spots !== 1 ? 's' : ''} remaining!`);
        
        // Update price display
        updateUnifiedPriceDisplay();
    }
    
    // Update previous state
    window.previousModalAvailability = {
        available_spots: availability.available_spots,
        canBookShared: sharedOption ? sharedOption.available : false,
        canBookPrivate: privateOption ? privateOption.available : false
    };
}

// Show availability warning (less severe than error)
function showAvailabilityWarning(message) {
    const notification = document.createElement('div');
    notification.className = 'fixed top-4 right-4 z-[70] max-w-sm animate-slide-in';
    notification.innerHTML = `
        <div class="bg-gradient-to-br from-yellow-900/95 to-orange-800/95 backdrop-blur-xl rounded-xl p-4 border-2 border-yellow-500/50 shadow-xl">
            <div class="flex items-center gap-3">
                <div class="flex-shrink-0">
                    <i class="bi bi-exclamation-circle-fill text-yellow-300 text-xl"></i>
                </div>
                <div class="flex-1">
                    <p class="text-yellow-100 text-sm font-medium">${message}</p>
                </div>
                <button onclick="this.closest('.fixed').remove()" class="text-yellow-300 hover:text-white transition-colors">
                    <i class="bi bi-x-lg"></i>
                </button>
            </div>
        </div>
    `;
    
    document.body.appendChild(notification);
    
    // Auto-remove after 5 seconds
    setTimeout(() => {
        if (notification.parentElement) {
            notification.style.opacity = '0';
            setTimeout(() => notification.remove(), 300);
        }
    }, 5000);
}

function stopPolling() {
    if (pollingInterval) {
        clearInterval(pollingInterval);
        pollingInterval = null;
    }
    
    // Hide live indicator
    const liveIndicator = document.getElementById('liveIndicator');
    if (liveIndicator) {
        liveIndicator.style.opacity = '0';
    }
}

// Store current slots data for comparison
let currentSlotsData = null;

function updateSlotsIfChanged(newSlots) {
    // Convert to JSON string for simple comparison
    const newSlotsStr = JSON.stringify(newSlots);
    const currentSlotsStr = JSON.stringify(currentSlotsData);
    
    if (newSlotsStr !== currentSlotsStr) {
        currentSlotsData = newSlots;
        renderSlots(newSlots);
        
        // Show subtle notification
        showUpdateNotification();
        
        return true; // Changes detected
    }
    
    return false; // No changes
}

function showUpdateNotification() {
    const notification = document.createElement('div');
    notification.className = 'fixed top-4 right-4 z-50 glass rounded-xl px-4 py-3 max-w-sm transform translate-x-full transition-transform duration-300 border-success/30 text-success';
    notification.innerHTML = `
        <div class="flex items-center gap-3">
            <svg class="w-5 h-5 flex-shrink-0 animate-pulse" fill="currentColor" viewBox="0 0 16 16">
                <path d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zm.93-9.412-1 4.705c-.07.34.029.533.304.533.194 0 .487-.07.686-.246l-.088.416c-.287.346-.92.598-1.465.598-.703 0-1.002-.422-.808-1.319l.738-3.468c.064-.293.006-.399-.287-.47l-.451-.081.082-.381 2.29-.287zM8 5.5a1 1 0 1 1 0-2 1 1 0 0 1 0 2z"/>
            </svg>
            <span class="text-sm font-medium">Availability updated</span>
        </div>
    `;
    
    document.body.appendChild(notification);
    
    // Animate in
    setTimeout(() => {
        notification.style.transform = 'translateX(0)';
    }, 100);
    
    // Auto remove after 3 seconds
    setTimeout(() => {
        notification.style.transform = 'translateX(full)';
        setTimeout(() => {
            notification.remove();
        }, 300);
    }, 3000);
}

// Pause polling when page is not visible
document.addEventListener('visibilitychange', function() {
    if (document.hidden) {
        stopPolling();
    } else {
        // Immediately refresh when page becomes visible
        loadSlotsForDate(currentDate);
        startPolling();
    }
});

// Load initial slots on page load
document.addEventListener('DOMContentLoaded', function() {
    loadSlotsForDate(currentDate);
    
    // Start real-time polling immediately after initial load
    setTimeout(() => {
        startPolling();
    }, 1000); // Wait 1 second before starting polling
});

// Clean up on page unload
window.addEventListener('beforeunload', function() {
    stopPolling();
});

</script>
{% endblock %}
